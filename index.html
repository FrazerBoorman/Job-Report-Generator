<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Job Report Generator</title>
  <meta name="color-scheme" content="light dark" />
  <!-- Google OAuth client ID -->
  <meta name="google-oauth-client-id"
        content="105230737516-l8tlnck4idde83pjetrotobpt8borvts.apps.googleusercontent.com" />
  <style>
    :root {
      --bg:#0f172a; --card:#020617; --panel:#020617; --border:#1e293b;
      --text:#e5e7eb; --muted:#94a3b8; --accent:#38bdf8; --accent-soft:rgba(56,189,248,0.12);
      --danger:#ef4444;
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg:#f8fafc; --card:#ffffff; --panel:#ffffff; --border:#e5e7eb;
        --text:#020617; --muted:#475569; --accent:#0ea5e9; --accent-soft:rgba(14,165,233,0.10);
        --danger:#b91c1c;
      }
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(900px 600px at 5% 0%, rgba(56,189,248,0.10), transparent 55%),
        radial-gradient(800px 600px at 95% 0%, rgba(129,140,248,0.12), transparent 50%),
        var(--bg);
      color: var(--text);
    }
    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 18px;
    }
    .card {
      background: var(--card);
      border-radius: 18px;
      border: 1px solid var(--border);
      padding: 18px 18px 20px;
      box-shadow: 0 18px 40px rgba(15,23,42,0.40);
    }
    h1 {
      margin: 0 0 6px;
      font-size: 26px;
      letter-spacing: .02em;
    }
    .muted { color: var(--muted); font-size: 14px; }
    .pill {
      display:inline-flex;align-items:center;gap:6px;
      font-size:11px;padding:3px 9px;border-radius:999px;
      border:1px solid var(--border);color:var(--muted);
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
    }
    label {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 4px;
      display:block;
    }
    input, select, textarea {
      width: 100%;
      font-size: 14px;
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      resize: vertical;
    }
    textarea { min-height: 60px; }
    input::placeholder, textarea::placeholder { color: var(--muted); }

    .btn-row { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    button {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 8px 13px;
      font-size: 14px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      background: var(--panel);
      color: var(--text);
      cursor:pointer;
      transition: transform .06s ease, box-shadow .12s ease, background .12s ease, border-color .12s ease;
    }
    button.primary {
      border-color: var(--accent);
      background: linear-gradient(180deg, var(--accent-soft), transparent);
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(15,23,42,0.5);
    }

    .section {
      margin-top: 16px;
      padding: 12px;
      border-radius: 12px;
      background: rgba(15,23,42,0.6);
      border: 1px dashed var(--border);
    }
    @media (prefers-color-scheme: light) {
      .section { background: #f9fafb; }
    }
    .section-title {
      font-size: 13px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: var(--muted);
      margin-bottom: 6px;
    }

    details.contacts { margin-top:6px; }
    details.contacts summary {
      cursor:pointer;
      font-size: 13px;
      color: var(--muted);
    }

    .small-note { font-size: 11px; color: var(--muted); margin-top: 3px; }

    #reportPreview {
      border-radius: 14px;
      border: 1px solid var(--border);
      padding: 12px;
      background: var(--panel);
      max-height: 420px;
      overflow: auto;
      font-size: 13px;
      line-height: 1.5;
    }
    #reportPreview h1 { font-size: 16px; margin: 0 0 6px; }
    #reportPreview h2 { font-size: 14px; margin: 8px 0 4px; }
    #reportPreview p { margin: 2px 0 6px; }
    #reportPreview table { border-collapse: collapse; width: 100%; margin: 4px 0 8px; }
    #reportPreview th, #reportPreview td {
      border: 1px solid var(--border);
      padding: 4px 6px;
      font-size: 12px;
      vertical-align: top;
    }

    .file-list { font-size: 12px; color: var(--muted); margin-top:4px; }
  </style>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:10px; flex-wrap:wrap;">
        <div>
          <h1>Job Report Generator</h1>
          <div class="muted">
            Sign into Google, pick a job, let AI fill the sections and then polish the whole report.
          </div>
        </div>
        <span class="pill">Frazer · AVD Tools</span>
      </div>

      <!-- Calendar selection -->
      <div class="section">
        <div class="section-title">Step 1 – Load recent jobs from calendar</div>
        <div class="grid">
          <div>
            <label for="calendarId">Calendar ID</label>
            <input id="calendarId"
              value="bb14db72acb2ffd4230316960d02103fa66e54901522ff7b8113eec682f6d42e@group.calendar.google.com" />
            <div class="small-note">
              Used to load jobs from the last 14 days and today.
            </div>
          </div>
          <div>
            <label for="eventSelect">Recent events (last 14 days + today)</label>
            <select id="eventSelect">
              <option value="">Sign in to load events…</option>
            </select>
            <div id="authStatus" class="small-note">Status: Waiting for sign-in…</div>
            <div id="aiStatus" class="small-note"></div>
          </div>
          <div style="align-self:end;">
            <button id="signinBtn" class="primary" type="button">Sign into Google</button>
            <div class="small-note">One tap. After that, events load &amp; AI can auto-fill.</div>
          </div>
        </div>
      </div>

      <!-- Report fields -->
      <div class="section">
        <div class="section-title">Step 2 – Job details</div>
        <div class="grid">
          <div>
            <label for="employee">Employee</label>
            <input id="employee" placeholder="Filled from calendar name (e.g. Frazer) if possible" />
          </div>
          <div>
            <label for="jobType">Job type</label>
            <select id="jobType">
              <option value="">— Select job type —</option>
              <option value="TCO">TCO (Technical Call Out)</option>
              <option value="RTF">RTF (Return To Fix)</option>
              <option value="Meeting / Consultation">Meeting / Consultation</option>
              <option value="Recce">Recce</option>
              <option value="Job / Installation">Job / Installation</option>
            </select>
            <div class="small-note">
              AI will set this if it can. Otherwise you choose.
            </div>
          </div>
          <div>
            <label for="jobDate">Job date</label>
            <input id="jobDate" type="date" />
          </div>
          <div>
            <label for="jobAddress">Address / site</label>
            <input id="jobAddress" placeholder="From title, location or description" />
          </div>
        </div>

        <div style="margin-top:10px;">
          <label for="jobDescription">Job description</label>
          <textarea id="jobDescription"
            placeholder="Summary of what you were supposed to do. AI fills this from the event and tidies it."></textarea>
        </div>

        <div style="margin-top:10px;">
          <label for="techCheck">Tech check summary</label>
          <textarea id="techCheck"
            placeholder="TECH CHECK style notes from the event/linked docs. AI will also tidy this on generate."></textarea>
          <div id="techLinks" class="small-note"></div>
        </div>
      </div>

      <div class="section">
        <div class="section-title">Step 3 – People &amp; time on site</div>
        <div class="grid">
          <div>
            <label for="personsMet">Person(s) met</label>
            <input id="personsMet" placeholder="Name(s) of contact(s) on site" />
          </div>
        </div>

        <details class="contacts">
          <summary>Contact details (optional)</summary>
          <div class="grid" style="margin-top:6px;">
            <div>
              <label for="contactPhone">Phone</label>
              <input id="contactPhone" />
            </div>
            <div>
              <label for="contactEmail">Email</label>
              <input id="contactEmail" />
            </div>
            <div>
              <label for="contactAddress">Postal address (if office need to post something)</label>
              <textarea id="contactAddress"></textarea>
            </div>
          </div>
        </details>

        <div id="timeOnSiteBlock" style="margin-top:10px; display:none;">
          <label>Time on site (for TCO/RTF)</label>
          <div class="row" style="display:flex;gap:10px;flex-wrap:wrap;">
            <div style="flex:1 1 160px;">
              <label for="timeArrived" style="font-weight:500;font-size:12px;">Arrived</label>
              <input id="timeArrived" type="time" />
            </div>
            <div style="flex:1 1 160px;">
              <label for="timeLeft" style="font-weight:500;font-size:12px;">Left</label>
              <input id="timeLeft" type="time" />
            </div>
            <div style="flex:1 1 200px;">
              <label style="font-weight:500;font-size:12px;">Duration</label>
              <input id="timeDuration" readonly />
            </div>
          </div>
          <div class="small-note">Ignored for Job / Installation unless you want to note it.</div>
        </div>
      </div>

      <div class="section">
        <div class="section-title">Step 4 – Findings &amp; advisories</div>
        <div class="grid">
          <div>
            <label for="findings">Findings</label>
            <textarea id="findings"
              placeholder="Short, brief sentences describing what you found. AI turns these into a clean paragraph in the report."></textarea>
          </div>
          <div>
            <label for="howLeft">How things have been left</label>
            <textarea id="howLeft"
              placeholder="Short bullet-style notes. AI turns these into a paragraph in the report."></textarea>
          </div>
        </div>
        <div style="margin-top:10px;">
          <label for="advisories">Advisories</label>
          <textarea id="advisories"
            placeholder="Short notes (future improvements, risks). AI turns these into clear sentences/paragraphs."></textarea>
        </div>
      </div>

      <div class="section">
        <div class="section-title">Step 5 – Photos / videos</div>
        <div>
          <label for="mediaFiles">Upload photos / videos</label>
          <input id="mediaFiles" type="file" accept="image/*,video/*" multiple />
          <div class="small-note">
            Files stay local in your browser. They can’t be emailed automatically from here,
            but they’ll be listed in the report so you know what to attach.
          </div>
          <div id="mediaList" class="file-list"></div>
        </div>
      </div>

      <div class="section">
        <div class="section-title">Step 6 – Generate, check &amp; send</div>
        <div class="btn-row">
          <button id="generateBtn" class="primary" type="button">Generate report</button>
          <button id="viewBtn" type="button">View report</button>
          <button id="copyBtn" type="button">Copy report text</button>
          <button id="downloadDocBtn" type="button">Download Word (.doc)</button>
          <button id="sendBtn" type="button">Send (opens email)</button>
        </div>
        <div class="small-note">
          “Send” opens your email client addressed to Neil, Mark &amp; David with the report text.
          Attach the Word doc + photos/videos manually.
        </div>

        <div style="margin-top:10px;">
          <label>Report preview</label>
          <div id="reportPreview">No report generated yet.</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ======================
    //  CONFIG / CONSTANTS
    // ======================
    const CLIENT_ID = "105230737516-l8tlnck4idde83pjetrotobpt8borvts.apps.googleusercontent.com";
    const SCOPES   = "https://www.googleapis.com/auth/calendar.readonly";
    const OPENAI_MODEL = "gpt-4.1-mini";
    const OPENAI_KEY_STORAGE = "avd_job_report_openai_key"; // set via console once

    // To set your OpenAI key once, open browser devtools console on this page and run:
    // localStorage.setItem('avd_job_report_openai_key', 'sk-REPLACE_WITH_YOUR_KEY');

    let accessToken = null;
    let tokenClient = null;
    let currentEvents = [];
    let lastReportText = "";
    let lastReportData = null;

    function setStatus(msg, ok) {
      const el = document.getElementById("authStatus");
      if (!el) return;
      el.textContent = "Status: " + msg;
      el.style.color = ok === false ? "var(--danger)" : "";
    }

    function setAiStatus(msg, ok) {
      const el = document.getElementById("aiStatus");
      if (!el) return;
      el.textContent = msg;
      el.style.color = ok === false ? "var(--danger)" : "";
    }

    // ======================
    //  GOOGLE AUTH & EVENTS
    // ======================
    function initAuth() {
      if (!window.google || !google.accounts || !google.accounts.oauth2) return;
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        prompt: "",
        callback: function(resp) {
          if (resp && resp.access_token) {
            accessToken = resp.access_token;
            setStatus("Signed in. Loading last 14 days…", true);
            loadRecentEvents();
          } else {
            setStatus("Sign-in failed.", false);
          }
        }
      });
    }

    function signInManual() {
      if (!tokenClient) initAuth();
      if (!tokenClient) {
        setStatus("Google auth not ready.", false);
        return;
      }
      tokenClient.requestAccessToken();
    }

    function getEventStartDate(ev) {
      if (!ev || !ev.start) return null;
      if (ev.start.date) return new Date(ev.start.date + "T00:00:00Z");
      if (ev.start.dateTime) return new Date(ev.start.dateTime);
      return null;
    }

    function extractPrimaryDate(ev) {
      if (!ev || !ev.start) return "";
      if (ev.start.date) return ev.start.date;
      if (ev.start.dateTime) return ev.start.dateTime.slice(0, 10);
      return "";
    }

    async function setEmployeeFromCalendar(calId) {
      const employeeInput = document.getElementById("employee");
      if (employeeInput.value) return; // don't overwrite manual value
      if (!accessToken) return;

      try {
        const url = "https://www.googleapis.com/calendar/v3/calendars/" + encodeURIComponent(calId);
        const res = await fetch(url, {
          headers: { "Authorization": "Bearer " + accessToken }
        });
        if (res.ok) {
          const data = await res.json();
          if (data.summary && typeof data.summary === "string") {
            const name = data.summary.trim();
            if (name) {
              employeeInput.value = name; // e.g. "Frazer"
              return;
            }
          }
        }
      } catch (e) {
        console.error("Error fetching calendar summary:", e);
      }
      // Fallback: derive from calendarId email local-part
      deriveEmployeeFromCalendarId(calId);
    }

    async function loadRecentEvents() {
      if (!accessToken) {
        setStatus("No access token yet.", false);
        return;
      }

      const calId = (document.getElementById("calendarId").value || "primary").trim();

      // Fill Employee from calendar summary (e.g. "Frazer")
      await setEmployeeFromCalendar(calId);

      // Last 14 days (inclusive) up to end of today
      const now = new Date();
      const end = new Date(now);
      end.setHours(23, 59, 59, 999);

      const start = new Date(now);
      start.setDate(start.getDate() - 14);
      start.setHours(0, 0, 0, 0);

      const url = new URL(
        "https://www.googleapis.com/calendar/v3/calendars/" +
        encodeURIComponent(calId) +
        "/events"
      );

      url.searchParams.set("singleEvents", "true");
      url.searchParams.set("orderBy", "startTime");
      url.searchParams.set("timeMin", start.toISOString());
      url.searchParams.set("timeMax", end.toISOString());
      url.searchParams.set("maxResults", "250");

      const res = await fetch(url.toString(), {
        headers: { "Authorization": "Bearer " + accessToken }
      });

      if (!res.ok) {
        setStatus("Calendar API error " + res.status, false);
        return;
      }

      const data = await res.json();
      const all = data.items || [];
      const nowRef = new Date();

      // Filter to events in this window, sort newest first
      const processed = all
        .map(ev => ({ ev, startDate: getEventStartDate(ev) }))
        .filter(obj => obj.startDate && obj.startDate <= nowRef)
        .sort((a, b) => b.startDate - a.startDate);

      const picked = processed.map(x => x.ev);
      currentEvents = picked;

      const sel = document.getElementById("eventSelect");
      sel.innerHTML = "";

      if (!picked.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No events in the last 14 days.";
        sel.appendChild(opt);
        setStatus("No events in the last 14 days.", false);
        return;
      }

      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "— Select job —";
      sel.appendChild(placeholder);

      for (let i = 0; i < picked.length; i++) {
        const ev = picked[i];
        const title = ev.summary || "(no title)";
        const d = extractPrimaryDate(ev);
        const opt = document.createElement("option");
        opt.value = String(i);
        opt.textContent = (d ? (d + " – ") : "") + title;
        sel.appendChild(opt);
      }

      setStatus("Loaded " + picked.length + " events from last 14 days.", true);

      // Auto-select newest and AI scalp
      if (picked.length > 0) {
        sel.selectedIndex = 1; // first real event
        aiParseSelectedEvent();
      }
    }

    function deriveEmployeeFromCalendarId(calId) {
      const employeeInput = document.getElementById("employee");
      if (!calId || employeeInput.value) return;
      if (calId.indexOf("@") === -1) return;
      const local = calId.split("@")[0];
      const parts = local.split(".");
      if (parts.length >= 2) {
        const name = parts.map(p => p.charAt(0).toUpperCase() + p.slice(1)).join(" ");
        employeeInput.value = name;
      }
    }

    // ======================
    //  BASIC (NON-AI) EXTRACTION
    // ======================
    function detectJobTypeFromText(title, desc) {
      const text = (title + " " + desc).toLowerCase();
      if (text.includes("tco") || text.includes("technical call out")) return "TCO";
      if (text.includes("rtf") || text.includes("return to fix")) return "RTF";
      if (text.includes("recce") || text.includes("site visit") || text.includes("survey")) return "Recce";
      if (text.includes("install") || text.includes("installation") || text.includes("job/installation")) return "Job / Installation";
      if (text.includes("meeting") || text.includes("consultation") || text.includes("consult")) return "Meeting / Consultation";
      return "";
    }

    function basicJobDescription(summary, description) {
      let lines = [];
      if (summary) lines.push(summary.trim());
      if (description) {
        const descLines = description.split(/\r?\n/);
        const trimmed = [];
        for (let i = 0; i < descLines.length; i++) {
          const l = descLines[i].trim();
          if (!l) continue;
          if (/^\d{4}-\d{2}-\d{2}/.test(l)) continue;
          if (/^\d{2}\/\d{2}\/\d{4}/.test(l)) continue;
          trimmed.push(l);
        }
        for (let j = 0; j < trimmed.length && j < 5; j++) lines.push(trimmed[j]);
      }
      return lines.join("\n");
    }

    function extractTechCheck(description) {
      if (!description) return { summary: "", links: [] };
      const lines = description.split(/\r?\n/);
      const techLines = [];
      const links = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lower = line.toLowerCase();
        if (lower.includes("tech check") || lower.includes("techcheck")) {
          techLines.push(line.trim());
        }
        const urlMatch = line.match(/https?:\/\/\S+/g);
        if (urlMatch) {
          for (let k = 0; k < urlMatch.length; k++) {
            const u = urlMatch[k];
            const ul = u.toLowerCase();
            if (ul.includes("tech") || ul.includes("check")) {
              links.push(u);
            }
          }
        }
      }
      return { summary: techLines.join("\n"), links };
    }

    function extractContacts(description) {
      if (!description) return { persons:"", phone:"", email:"" };
      const lines = description.split(/\r?\n/);
      const persons = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lower = line.toLowerCase();
        if (
          lower.includes("contact:") ||
          lower.includes("contact -") ||
          lower.includes("on-site contact") ||
          lower.includes("onsite contact") ||
          lower.startsWith("meeting with") ||
          lower.startsWith("meet ")
        ) {
          const cleaned = line.replace(/.*:/, "").trim();
          if (cleaned) persons.push(cleaned);
        }
      }
      const emailMatch = description.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i);
      const phoneMatch = description.match(/\b(?:0\d{9,10}|\+?\d[\d\s\-]{7,}\d)\b/);
      return {
        persons: persons.join(", "),
        phone: phoneMatch ? phoneMatch[0] : "",
        email: emailMatch ? emailMatch[0] : ""
      };
    }

    function fallbackFillFromEvent(ev) {
      const title = ev.summary || "";
      const desc  = ev.description || "";
      const loc   = ev.location || "";

      const jt = detectJobTypeFromText(title, desc);
      const jobTypeSel = document.getElementById("jobType");
      jobTypeSel.value = jt || "";
      updateTimeOnSiteVisibility();

      const dateStr = extractPrimaryDate(ev);
      if (dateStr) document.getElementById("jobDate").value = dateStr;

      const addrInput = document.getElementById("jobAddress");
      if (!addrInput.value) {
        if (loc) addrInput.value = loc;
        else if (title) addrInput.value = title; // title often includes hall name + town
      }

      document.getElementById("jobDescription").value = basicJobDescription(title, desc);

      const tech = extractTechCheck(desc);
      document.getElementById("techCheck").value = tech.summary || "";
      const techLinksDiv = document.getElementById("techLinks");
      if (tech.links.length) {
        let html = "Tech check links: ";
        for (let i = 0; i < tech.links.length; i++) {
          const u = tech.links[i];
          html += '<a href="' + u + '" target="_blank" rel="noopener">' + u + "</a>";
          if (i < tech.links.length - 1) html += " · ";
        }
        techLinksDiv.innerHTML = html;
      } else {
        techLinksDiv.textContent = "";
      }

      const contacts = extractContacts(desc);
      if (contacts.persons && !document.getElementById("personsMet").value) {
        document.getElementById("personsMet").value = contacts.persons;
      }
      if (contacts.phone && !document.getElementById("contactPhone").value) {
        document.getElementById("contactPhone").value = contacts.phone;
      }
      if (contacts.email && !document.getElementById("contactEmail").value) {
        document.getElementById("contactEmail").value = contacts.email;
      }
    }

    // ======================
    //  TIME ON SITE
    // ======================
    function timeToMinutes(t) {
      if (!t) return null;
      const parts = t.split(":");
      if (parts.length !== 2) return null;
      const h = Number(parts[0]);
      const m = Number(parts[1]);
      if (isNaN(h) || isNaN(m)) return null;
      return h * 60 + m;
    }

    function minutesToHm(mins) {
      if (mins == null || isNaN(mins)) return "";
      const h = Math.floor(mins / 60);
      const m = Math.round(mins % 60);
      return h + "h " + String(m).padStart(2, "0") + "m";
    }

    function updateTimeOnSiteVisibility() {
      const jt = document.getElementById("jobType").value;
      const block = document.getElementById("timeOnSiteBlock");
      if (jt === "TCO" || jt === "RTF") {
        block.style.display = "block";
      } else {
        block.style.display = "none";
      }
    }

    function recalcTimeOnSite() {
      const start = timeToMinutes(document.getElementById("timeArrived").value);
      const end   = timeToMinutes(document.getElementById("timeLeft").value);
      let dur = "";
      if (start != null && end != null) {
        let diff = end - start;
        if (diff < 0) diff += 24 * 60;
        dur = minutesToHm(diff);
      }
      document.getElementById("timeDuration").value = dur;
    }

    // ======================
    //  MEDIA LIST
    // ======================
    function updateMediaList() {
      const input = document.getElementById("mediaFiles");
      const listDiv = document.getElementById("mediaList");
      if (!input.files || !input.files.length) {
        listDiv.textContent = "No media selected.";
        return;
      }
      const names = [];
      for (let i = 0; i < input.files.length; i++) {
        const f = input.files[i];
        names.push(f.name + " (" + Math.round(f.size / 1024) + " KB)");
      }
      listDiv.innerHTML = "Attached (" + input.files.length + "):<br>" +
        names.map(n => "• " + n).join("<br>");
    }

    // ======================
    //  TEXT FLUFFING (fallback)
    // ======================
    function expandNotes(raw) {
      if (!raw) return "";
      const lines = raw.split(/\r?\n/);
      const kept = [];
      for (let i = 0; i < lines.length; i++) {
        const l = lines[i].trim();
        if (l) kept.push(l);
      }
      if (!kept.length) return "";
      const sentences = kept.map(line => {
        let s = line;
        if (!/[.!?]$/.test(s)) s += ".";
        s = s.charAt(0).toUpperCase() + s.slice(1);
        return s;
      });
      return sentences.join(" ");
    }

    // ======================
    //  OPENAI – EVENT SCALP
    // ======================
    async function aiParseSelectedEvent() {
      const sel = document.getElementById("eventSelect");
      if (!sel.value) {
        setAiStatus("Select a job from the list.", false);
        return;
      }
      const ev = currentEvents[Number(sel.value)];
      if (!ev) {
        setAiStatus("Selected event not found.", false);
        return;
      }

      const apiKey = localStorage.getItem(OPENAI_KEY_STORAGE);
      const title = ev.summary || "";
      const desc  = ev.description || "";
      const loc   = ev.location || "";
      const start = ev.start || {};
      const end   = ev.end || {};
      const attendees = ev.attendees || [];

      if (!apiKey) {
        fallbackFillFromEvent(ev);
        setAiStatus("No OpenAI key set (using basic extraction only).", false);
        return;
      }

      const eventData = {
        title,
        description: desc,
        location: loc,
        start,
        end,
        attendees
      };

      const systemPrompt =
        "You are helping an audio-visual company engineer interpret a Google Calendar job event.\n" +
        "You receive a JSON object with title, description, location, start, end, attendees.\n" +
        "Your job is to fill as many report fields as possible using ONLY information present in those fields.\n" +
        "You must NOT invent any details from thin air.\n\n" +
        "Use ALL of: title, description, and location to find:\n" +
        "- job type (TCO, RTF, Meeting / Consultation, Recce, Job / Installation)\n" +
        "- job description\n" +
        "- tech check notes\n" +
        "- persons met\n" +
        "- contact phone / email / address\n" +
        "- job date\n" +
        "- address/site (hall / church name, town, postcode etc)\n\n" +
        "If something is not clearly supported by the event text, leave that field empty.\n\n" +
        "Return STRICT JSON ONLY in this format:\n" +
        "{\n" +
        '  "jobType": "TCO | RTF | Meeting / Consultation | Recce | Job / Installation | \\"\\\"",\n' +
        '  "jobDescription": "1–3 sentence description of what the visit is about, using only event details",\n' +
        '  "techCheckSummary": "summary of any TECH CHECK style notes, or empty string",\n' +
        '  "personsMet": "names of people expected / met on site if mentioned, comma separated",\n' +
        '  "contactPhone": "phone number if present, else empty string",\n' +
        '  "contactEmail": "email address if present, else empty string",\n' +
        '  "contactAddress": "postal or site address text, if present (title/description/location), else empty string",\n' +
        '  "jobDate": "YYYY-MM-DD if obvious from the event start, else empty string",\n' +
        '  "jobAddress": "best guess at site name/address (title and/or location), else empty string"\n' +
        "}\n\n" +
        "If you are not sure about any field, return an empty string for that field.\n" +
        "Do NOT include explanations. Only output the JSON object.";

      setAiStatus("AI scalping selected event…", true);

      try {
        const res = await fetch("https://api.openai.com/v1/responses", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + apiKey
          },
          body: JSON.stringify({
            model: OPENAI_MODEL,
            input: [
              { role: "system", content: systemPrompt },
              { role: "user", content: JSON.stringify(eventData) }
            ]
          })
        });

        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          console.error("OpenAI error:", res.status, txt);
          setAiStatus("OpenAI error " + res.status + ". Basic extraction used instead.", false);
          fallbackFillFromEvent(ev);
          return;
        }

        const data = await res.json();
        let rawText = "";
        if (
          data.output &&
          data.output[0] &&
          data.output[0].content &&
          data.output[0].content[0] &&
          data.output[0].content[0].text
        ) {
          rawText = data.output[0].content[0].text;
        }

        let parsed;
        try {
          parsed = JSON.parse(rawText);
        } catch (e) {
          console.error("Failed to parse JSON from OpenAI:", rawText);
          setAiStatus("AI format issue. Basic extraction used instead.", false);
          fallbackFillFromEvent(ev);
          return;
        }

        // Start with fallback, then overlay AI where it gives values
        fallbackFillFromEvent(ev);

        const jobTypeSel = document.getElementById("jobType");
        if (parsed.jobType) jobTypeSel.value = parsed.jobType;

        if (parsed.jobDescription) {
          document.getElementById("jobDescription").value = parsed.jobDescription;
        }
        if (parsed.techCheckSummary) {
          document.getElementById("techCheck").value = parsed.techCheckSummary;
        }
        if (parsed.personsMet) {
          document.getElementById("personsMet").value = parsed.personsMet;
        }
        if (parsed.contactPhone) {
          document.getElementById("contactPhone").value = parsed.contactPhone;
        }
        if (parsed.contactEmail) {
          document.getElementById("contactEmail").value = parsed.contactEmail;
        }
        if (parsed.contactAddress) {
          document.getElementById("contactAddress").value = parsed.contactAddress;
        }
        if (parsed.jobDate) {
          document.getElementById("jobDate").value = parsed.jobDate;
        } else {
          const dateStr = extractPrimaryDate(ev);
          if (dateStr) document.getElementById("jobDate").value = dateStr;
        }

        const addrInput = document.getElementById("jobAddress");
        if (parsed.jobAddress) {
          addrInput.value = parsed.jobAddress;
        } else if (!addrInput.value) {
          if (loc) addrInput.value = loc;
          else if (title) addrInput.value = title;
        }

        updateTimeOnSiteVisibility();
        setAiStatus("AI scalped event. Review & tweak as needed.", true);
      } catch (err) {
        console.error(err);
        setAiStatus("Network error talking to OpenAI. Basic extraction used instead.", false);
        fallbackFillFromEvent(ev);
      }
    }

    // ======================
    //  OPENAI – SECTION POLISH (from short notes)
    // ======================
    async function enhanceNotesWithAI(jobDesc, tech, findingsRaw, howRaw, advRaw) {
      const fallback = {
        jobDescriptionText: jobDesc || "",
        techSummaryText: tech || "",
        findingsText: expandNotes(findingsRaw),
        howLeftText: expandNotes(howRaw),
        advisoriesText: expandNotes(advRaw)
      };

      if (!jobDesc && !tech && !findingsRaw && !howRaw && !advRaw) return fallback;

      const apiKey = localStorage.getItem(OPENAI_KEY_STORAGE);
      if (!apiKey) return fallback;

      const payload = {
        jobDescription: jobDesc || "",
        techSummary: tech || "",
        shortFindings: findingsRaw || "",
        shortHowLeft: howRaw || "",
        shortAdvisories: advRaw || ""
      };

      const systemPrompt =
        "You help turn an AV engineer's rough job report notes into a clean, professional report.\n" +
        "You will receive five fields:\n" +
        "- jobDescription: a short description of the job / visit\n" +
        "- techSummary: any TECH CHECK / technical notes\n" +
        "- shortFindings: terse findings notes (bullets or fragments)\n" +
        "- shortHowLeft: terse notes on how things have been left\n" +
        "- shortAdvisories: terse advisories / next steps\n\n" +
        "For each field:\n" +
        "- Rewrite it into a clear, concise paragraph (or two at most) suitable for a report.\n" +
        "- Keep technical meaning and intent exactly the same.\n" +
        "- Do NOT invent new facts or speculate on anything that is not explicitly implied.\n" +
        "- If a field is empty or trivial, return an empty string for that field.\n\n" +
        "Return STRICT JSON ONLY in this format:\n" +
        "{\n" +
        '  "jobDescription": "polished job description or empty string",\n' +
        '  "techSummary": "polished tech summary or empty string",\n' +
        '  "findings": "polished findings paragraph or empty string",\n' +
        '  "howLeft": "polished how-left paragraph or empty string",\n' +
        '  "advisories": "polished advisories paragraph or empty string"\n' +
        "}\n" +
        "No explanations, just the JSON object.";

      try {
        const res = await fetch("https://api.openai.com/v1/responses", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + apiKey
          },
          body: JSON.stringify({
            model: OPENAI_MODEL,
            input: [
              { role: "system", content: systemPrompt },
              { role: "user", content: JSON.stringify(payload) }
            ]
          })
        });

        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          console.error("OpenAI notes error:", res.status, txt);
          return fallback;
        }

        const data = await res.json();
        let rawText = "";
        if (
          data.output &&
          data.output[0] &&
          data.output[0].content &&
          data.output[0].content[0] &&
          data.output[0].content[0].text
        ) {
          rawText = data.output[0].content[0].text;
        }

        let parsed;
        try {
          parsed = JSON.parse(rawText);
        } catch (e) {
          console.error("Failed to parse JSON from OpenAI (notes):", rawText);
          return fallback;
        }

        return {
          jobDescriptionText: parsed.jobDescription || fallback.jobDescriptionText,
          techSummaryText: parsed.techSummary || fallback.techSummaryText,
          findingsText: parsed.findings || fallback.findingsText,
          howLeftText: parsed.howLeft || fallback.howLeftText,
          advisoriesText: parsed.advisories || fallback.advisoriesText
        };
      } catch (e) {
        console.error("Notes AI error:", e);
        return fallback;
      }
    }

    // ======================
    //  OPENAI – WHOLE REPORT POLISH (second pass)
    // ======================
    async function polishWholeReportWithAI(reportText) {
      const apiKey = localStorage.getItem(OPENAI_KEY_STORAGE);
      if (!apiKey || !reportText) return reportText;

      const systemPrompt =
        "You will be given a complete job report written by an AV engineer, with headings and sections.\n" +
        "Rewrite the report so it reads like a polished, professional document, as if it has been tidied up by an experienced writer.\n" +
        "Rules:\n" +
        "- Keep ALL existing headings and their order (e.g. 'Job Report', 'Site & description', 'Tech check summary').\n" +
        "- Preserve all factual content exactly. Do NOT add new jobs, dates, times, components, or incidents.\n" +
        "- You may merge short choppy sentences, remove duplication, and improve flow.\n" +
        "- You may adjust punctuation, phrasing and connectors, but not meaning.\n" +
        "- Do not add new sections. Do not remove any headings.\n" +
        "- Output plain text only with the same headings present.\n";

      try {
        const res = await fetch("https://api.openai.com/v1/responses", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + apiKey
          },
          body: JSON.stringify({
            model: OPENAI_MODEL,
            input: [
              { role: "system", content: systemPrompt },
              { role: "user", content: reportText }
            ]
          })
        });

        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          console.error("OpenAI whole-report error:", res.status, txt);
          return reportText;
        }

        const data = await res.json();
        if (
          data.output &&
          data.output[0] &&
          data.output[0].content &&
          data.output[0].content[0] &&
          data.output[0].content[0].text
        ) {
          return data.output[0].content[0].text;
        }
        return reportText;
      } catch (e) {
        console.error("Whole-report polish error:", e);
        return reportText;
      }
    }

    // ======================
    //  REPORT DATA & BUILDERS
    // ======================
    function collectFormData() {
      const mediaInput = document.getElementById("mediaFiles");
      const mediaItems = [];
      if (mediaInput.files) {
        for (let i = 0; i < mediaInput.files.length; i++) {
          mediaItems.push(mediaInput.files[i].name);
        }
      }

      return {
        employee: document.getElementById("employee").value.trim(),
        jobType: document.getElementById("jobType").value,
        jobDate: document.getElementById("jobDate").value,
        jobAddr: document.getElementById("jobAddress").value.trim(),
        jobDesc: document.getElementById("jobDescription").value.trim(),
        tech: document.getElementById("techCheck").value.trim(),
        persons: document.getElementById("personsMet").value.trim(),
        cPhone: document.getElementById("contactPhone").value.trim(),
        cEmail: document.getElementById("contactEmail").value.trim(),
        cAddr: document.getElementById("contactAddress").value.trim(),
        timeArrived: document.getElementById("timeArrived").value,
        timeLeft: document.getElementById("timeLeft").value,
        timeDuration: document.getElementById("timeDuration").value.trim(),
        findingsRaw: document.getElementById("findings").value.trim(),
        howLeftRaw: document.getElementById("howLeft").value.trim(),
        advisoriesRaw: document.getElementById("advisories").value.trim(),
        mediaItems
      };
    }

    function buildReportHtmlBody(data) {
      const {
        employee, jobType, jobDate, jobAddr, jobDesc, tech,
        persons, cPhone, cEmail, cAddr,
        timeArrived, timeLeft, timeDuration,
        findingsText, howLeftText, advisoriesText,
        mediaItems
      } = data;

      const title = "Job Report" +
        (jobType ? " – " + jobType : "") +
        (jobDate ? " – " + jobDate : "");

      const header =
        "<h1>" + title + "</h1>" +
        "<table>" +
          "<tr><th style=\"width:20%\">Employee</th><td>" + (employee || "–") + "</td></tr>" +
          "<tr><th>Job type</th><td>" + (jobType || "–") + "</td></tr>" +
          "<tr><th>Date</th><td>" + (jobDate || "–") + "</td></tr>" +
          "<tr><th>Address / site</th><td>" + (jobAddr || "–") + "</td></tr>" +
          "<tr><th>Person(s) met</th><td>" + (persons || "–") + "</td></tr>" +
        "</table>";

      const contactBits = [];
      if (cPhone) contactBits.push("Phone: " + cPhone);
      if (cEmail) contactBits.push("Email: " + cEmail);
      if (cAddr)  contactBits.push("Postal address: " + cAddr.replace(/\n/g, "; "));

      const sections = [];

      sections.push("<h2>Job description</h2>");
      sections.push("<p>" + (jobDesc ? jobDesc.replace(/\n/g, "<br>") : "–") + "</p>");

      sections.push("<h2>Tech check summary</h2>");
      sections.push("<p>" + (tech ? tech.replace(/\n/g, "<br>") : "–") + "</p>");

      sections.push("<h2>Contacts</h2>");
      let contactHtml = "<p><b>Person(s) met:</b> " + (persons || "–") + "</p>";
      if (contactBits.length) contactHtml += "<p>" + contactBits.join("<br>") + "</p>";
      sections.push(contactHtml);

      if (jobType === "TCO" || jobType === "RTF") {
        sections.push("<h2>Time on site</h2>");
        sections.push(
          "<p><b>Arrived:</b> " + (timeArrived || "–") +
          "<br><b>Left:</b> " + (timeLeft || "–") +
          "<br><b>Duration:</b> " + (timeDuration || "–") + "</p>"
        );
      }

      sections.push("<h2>Findings</h2>");
      sections.push("<p>" + (findingsText || "–") + "</p>");

      sections.push("<h2>How things have been left</h2>");
      sections.push("<p>" + (howLeftText || "–") + "</p>");

      sections.push("<h2>Advisories</h2>");
      sections.push("<p>" + (advisoriesText || "–") + "</p>");

      sections.push("<h2>Photos / videos</h2>");
      if (mediaItems && mediaItems.length) {
        sections.push("<ul>" + mediaItems.map(n => "<li>" + n + "</li>").join("") + "</ul>");
      } else {
        sections.push("<p>None listed.</p>");
      }

      return header + sections.join("");
    }

    function buildReportDocHtml(data) {
      const bodyHtml = buildReportHtmlBody(data);
      const css =
        "<style>" +
        "@page { size: A4; margin: 2cm; }" +
        "body { font-family: Calibri, Arial, sans-serif; font-size: 11pt; color: #000000; }" +
        "h1 { font-size: 16pt; margin: 0 0 6pt 0; }" +
        "h2 { font-size: 13pt; margin: 10pt 0 4pt 0; }" +
        "table { border-collapse: collapse; width: 100%; margin: 4pt 0 10pt 0; }" +
        "th, td { border: 1px solid #cccccc; padding: 4pt 6pt; vertical-align: top; }" +
        "th { background: #f0f0f0; font-weight: bold; }" +
        "p { margin: 0 0 6pt 0; }" +
        "ul { margin: 0 0 6pt 18pt; padding: 0; }" +
        "li { margin: 0 0 2pt 0; }" +
        "</style>";
      return "<!doctype html><html><head><meta charset=\"utf-8\"><title>Job Report</title>" +
             css + "</head><body>" + bodyHtml + "</body></html>";
    }

    function buildReportText(data) {
      const {
        employee, jobType, jobDate, jobAddr, jobDesc, tech,
        persons, cPhone, cEmail, cAddr,
        timeArrived, timeLeft, timeDuration,
        findingsText, howLeftText, advisoriesText,
        mediaItems
      } = data;

      const lines = [];
      lines.push("Job Report");
      lines.push("==========");
      lines.push("");
      lines.push("Employee: " + (employee || "-"));
      lines.push("Job type: " + (jobType || "-"));
      lines.push("Date: " + (jobDate || "-"));
      lines.push("");
      lines.push("Site & description");
      lines.push("------------------");
      lines.push("Address/site: " + (jobAddr || "-"));
      lines.push("");
      lines.push("Job description:");
      lines.push(jobDesc || "-");
      lines.push("");
      lines.push("Tech check summary");
      lines.push("------------------");
      lines.push(tech || "-");
      lines.push("");
      lines.push("Person(s) met & contacts");
      lines.push("------------------------");
      lines.push("Person(s) met: " + (persons || "-"));
      if (cPhone) lines.push("Phone: " + cPhone);
      if (cEmail) lines.push("Email: " + cEmail);
      if (cAddr)  lines.push("Postal address: " + cAddr.replace(/\r?\n/g, "; "));
      lines.push("");

      if (jobType === "TCO" || jobType === "RTF") {
        lines.push("Time on site");
        lines.push("------------");
        lines.push("Arrived: " + (timeArrived || "-"));
        lines.push("Left: " + (timeLeft || "-"));
        lines.push("Duration: " + (timeDuration || "-"));
        lines.push("");
      }

      lines.push("Findings");
      lines.push("--------");
      lines.push(findingsText || "-");
      lines.push("");
      lines.push("How things have been left");
      lines.push("-------------------------");
      lines.push(howLeftText || "-");
      lines.push("");
      lines.push("Advisories");
      lines.push("----------");
      lines.push(advisoriesText || "-");
      lines.push("");

      lines.push("Photos / videos");
      lines.push("---------------");
      if (mediaItems && mediaItems.length) {
        for (let i = 0; i < mediaItems.length; i++) {
          lines.push("• " + mediaItems[i]);
        }
      } else {
        lines.push("None listed.");
      }

      return lines.join("\n");
    }

    // ======================
    //  REPORT GENERATION
    // ======================
    async function generateReport() {
      const btn = document.getElementById("generateBtn");
      if (btn) btn.disabled = true;

      try {
        const data = collectFormData();

        // First AI pass: polish sections from your short notes
        const enhanced = await enhanceNotesWithAI(
          data.jobDesc,
          data.tech,
          data.findingsRaw,
          data.howLeftRaw,
          data.advisoriesRaw
        );

        data.jobDesc      = enhanced.jobDescriptionText;
        data.tech         = enhanced.techSummaryText;
        data.findingsText = enhanced.findingsText;
        data.howLeftText  = enhanced.howLeftText;
        data.advisoriesText = enhanced.advisoriesText;

        lastReportData = data;

        // Build HTML preview & Word document content from polished sections
        const htmlBody = buildReportHtmlBody(data);
        const preview = document.getElementById("reportPreview");
        preview.innerHTML = htmlBody;
        preview.scrollTop = 0;

        // Build structured plain-text report from the polished sections
        const baseText = buildReportText(data);

        // Second AI pass: polish the whole report text as if you fed it to ChatGPT
        const polishedText = await polishWholeReportWithAI(baseText);
        lastReportText = polishedText || baseText;
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    function viewReport() {
      if (!lastReportText) {
        generateReport();
      }
      document.getElementById("reportPreview").scrollIntoView({ behavior: "smooth", block: "start" });
    }

    async function copyReportText() {
      if (!lastReportText) await generateReport();
      try {
        await navigator.clipboard.writeText(lastReportText);
        alert("Report text copied to clipboard.");
      } catch (e) {
        alert("Could not copy automatically. You may need to select and copy from the preview.");
      }
    }

    function downloadWordDoc() {
      if (!lastReportData) {
        alert("Please generate the report first.");
        return;
      }
      const html = buildReportDocHtml(lastReportData);
      const jobDate  = lastReportData.jobDate || "";
      const jobType  = lastReportData.jobType || "job";
      const safeType = jobType.replace(/[^a-z0-9]+/gi, "_").toLowerCase();
      const fname = "job_report_" + safeType + (jobDate ? "_" + jobDate : "") + ".doc";
      const blob = new Blob([html], { type: "application/msword" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fname;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 0);
    }

    function sendReportEmail() {
      if (!lastReportText || !lastReportData) {
        alert("Please generate the report first.");
        return;
      }
      const jobType  = lastReportData.jobType || "Job";
      const jobDate  = lastReportData.jobDate || "";
      const jobAddr  = lastReportData.jobAddr || "";
      const subject  = "Job Report – " + jobType +
                       (jobDate ? (" – " + jobDate) : "") +
                       (jobAddr ? (" – " + jobAddr) : "");
      const to = [
        "Neil.Lovell@audiovisualdirectuk.co.uk",
        "Mark.Thyer@audiovisualdirectuk.co.uk",
        "David.Rolt@audiovisualdirectuk.co.uk"
      ].join(",");

      const body = encodeURIComponent(
        lastReportText +
        "\n\n(Photos/videos and the Word report are not attached automatically – please attach them manually.)"
      );
      const mailto = "mailto:" + encodeURIComponent(to) +
                     "?subject=" + encodeURIComponent(subject) +
                     "&body=" + body;
      window.location.href = mailto;
    }

    // ======================
    //  INIT
    // ======================
    window.addEventListener("DOMContentLoaded", function() {
      document.getElementById("signinBtn").addEventListener("click", signInManual);
      document.getElementById("mediaFiles").addEventListener("change", updateMediaList);
      document.getElementById("jobType").addEventListener("change", updateTimeOnSiteVisibility);
      document.getElementById("timeArrived").addEventListener("change", recalcTimeOnSite);
      document.getElementById("timeLeft").addEventListener("change", recalcTimeOnSite);
      document.getElementById("generateBtn").addEventListener("click", generateReport);
      document.getElementById("viewBtn").addEventListener("click", viewReport);
      document.getElementById("copyBtn").addEventListener("click", copyReportText);
      document.getElementById("downloadDocBtn").addEventListener("click", downloadWordDoc);
      document.getElementById("sendBtn").addEventListener("click", sendReportEmail);

      const eventSelect = document.getElementById("eventSelect");
      eventSelect.addEventListener("change", function() {
        if (eventSelect.value) aiParseSelectedEvent();
      });

      setStatus("Waiting for sign-in…", true);

      // Prepare Google auth (but don't auto-sign-in)
      window.setTimeout(() => {
        try { initAuth(); } catch (e) {}
      }, 0);
    });
  </script>
</body>
</html>
